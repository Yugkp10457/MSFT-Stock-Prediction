# -*- coding: utf-8 -*-
"""ARIMA-LSTM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LSI9eH3YYYfTsSXQxsyoZgYX3voSUUDg
"""

!pip install yfinance
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')
import seaborn as sns
import statsmodels as sm
import yfinance as yf
data = yf.download("AAPL MSFT TSLA", start="2020-01-01", end="2025-08-30")

import warnings
warnings.filterwarnings('ignore')

ticker = 'MSFT'
start_date = '2020-01-01'
end_date = '2025-09-30'
df = yf.download(ticker, start=start_date, end=end_date)

df.head()

df.tail()

df.info()

df.describe()

df.columns

df.index = pd.to_datetime(df.index)
df = df.sort_index()

print(df.isnull().sum())

plt.figure(figsize=(15,6))
plt.plot(df['Close'],label='MSFT Closing Price')
plt.title('MSFT Price Trend')
plt.legend()
plt.xlabel('Date')
plt.ylabel('Closing Prices')
plt.show()

target_col= df[['Close']].copy().astype(int) # converting data type to int
target_col.head(5)

from statsmodels.tsa.stattools import adfuller

result = adfuller(target_col['Close'])
print("ADF Statistic:", result[0])
print("p-value:", result[1])

target_col['Close_Diff'] = target_col['Close'].diff()

# Drop NaN created by differencing
diff_series = target_col['Close_Diff'].dropna()

# ADF Test
from statsmodels.tsa.stattools import adfuller

result = adfuller(diff_series)
print("ADF Statistic:", result[0])
print("p-value:", result[1])

target_col.head()

plt.figure(figsize=(15,6))
df['Close'].plot(kind='kde')

rolmean = target_col['Close'].rolling(12).mean()
rolstd = target_col['Close'].rolling(12).std()

plt.figure(figsize=(15,6))
plt.plot(target_col, color='blue')
plt.plot(rolmean, color='red', label='Rolling Mean')
plt.plot(rolstd, color='black', label='Rolling Std Dev')

plt.legend(loc='best')
plt.title('Rolling Mean and Standard Deviation')
plt.show()

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

plot_acf(df['Close'], lags=50)
plt.figure(figsize=(15,6))
plt.show()

plot_pacf(df['Close'], lags=50)
plt.figure(figsize=(15,6))
plt.show()

from statsmodels.tsa.seasonal import seasonal_decompose

decomposition = seasonal_decompose(df['Close'], model='multiplicative', period=252)  # ~252 trading days/year
decomposition.plot()
plt.figure(figsize=(15,6))
plt.show()

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

# Use log returns as the stationary series
log_ret = np.log(df['Close']).diff().dropna()

# ACF and PACF plots on logs of closing price
fig, ax = plt.subplots(1,2, figsize=(15,6))
plot_acf(log_ret, lags=40, ax=ax[0])
plot_pacf(log_ret, lags=40, ax=ax[1])
plt.show()

from statsmodels.tsa.arima.model import ARIMA

# Build ARIMA model (example with p=3, d=1, q=2)
model = ARIMA(df['Close'], order=(3,1,2))  # direct on price with differencing
model_fit = model.fit()

print(model_fit.summary())

train = df['Close'][:-365]
test = df['Close'][-365:]

# Fit ARIMA on training set
model = ARIMA(train, order=(3,1,2))  # adjust order after checking ACF/PACF
model_fit = model.fit()

# Forecast on test set length
forecast = model_fit.forecast(steps=len(test))

from sklearn.metrics import mean_squared_error, mean_absolute_error
import numpy as np

# Evaluation
rmse = np.sqrt(mean_squared_error(test, forecast))
mae = mean_absolute_error(test, forecast)

print("RMSE:", rmse)
print("MAE:", mae)

plt.figure(figsize=(15,6))
plt.plot(train.index, train, label='Train')
plt.plot(test.index, test, label='Forecast', color='orange')
plt.legend()
plt.title("ARIMA Forecast vs Actual")
plt.show()

import numpy as np
from sklearn.preprocessing import MinMaxScaler

# Assume df['Close'] is your MSFT close price series
data = df['Close'].values.reshape(-1,1)

scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(data)

train_size = len(df) - 365  # Use last 365 days for test
train_scaled = scaled_data[:train_size]
test_scaled = scaled_data[train_size:]

# Function to create time series sequences
def create_sequences(data, seq_length):
    xs, ys = [], []
    for i in range(seq_length, len(data)):
        xs.append(data[i-seq_length:i, 0])
        ys.append(data[i, 0])
    return np.array(xs), np.array(ys)

seq_length = 30  # Use 30 days to predict next day
X_train, y_train = create_sequences(train_scaled, seq_length)
X_test, y_test = create_sequences(test_scaled, seq_length)

X_train = X_train.reshape((X_train.shape[0], X_train.shape[1], 1))
X_test = X_test.reshape((X_test.shape[0], X_test.shape[1], 1))

from keras.models import Sequential
from keras.layers import LSTM, Dense, Dropout

model = Sequential([
    LSTM(units=50, return_sequences=True, input_shape=(seq_length,1)),
    Dropout(0.2),
    LSTM(units=50),
    Dropout(0.2),
    Dense(1)
])

model.compile(optimizer='adam', loss='mean_squared_error')
history = model.fit(X_train, y_train, epochs=30, batch_size=32, validation_split=0.1, verbose=2)

y_pred_scaled = model.predict(X_test)
y_pred = scaler.inverse_transform(y_pred_scaled.reshape(-1,1))
y_true = scaler.inverse_transform(y_test.reshape(-1,1))

from sklearn.metrics import mean_squared_error, mean_absolute_error
import numpy as np

rmse_lstm = np.sqrt(mean_squared_error(y_true, y_pred))
mae_lstm = mean_absolute_error(y_true, y_pred)

print("LSTM RMSE:", rmse_lstm)
print("LSTM MAE:", mae_lstm)

import matplotlib.pyplot as plt

plt.figure(figsize=(15,6))
plt.plot(df.index[-len(y_pred):], y_true, label="Actual")
plt.plot(df.index[-len(y_pred):], y_pred, label="LSTM Forecast", color="orange")
plt.title("LSTM Forecast vs Actual MSFT Prices")
plt.xlabel("Date")
plt.ylabel("MSFT Close Price")
plt.legend()
plt.show()

import matplotlib.pyplot as plt

# Suppose you have:
# test:           The actual MSFT closing prices (as a Pandas Series)
# forecast_arima: ARIMA model forecasts (numpy array or Pandas Series)
# forecast_lstm:  LSTM forecasts (numpy array, may be shorter by seq_length)

# Align LSTM forecast and ground truth if needed:
# If LSTM sequences mean your forecast is shorter, align the corresponding part of 'test':
lstm_offset = len(test) - len(y_pred)
test_lstm = test.iloc[lstm_offset:]

plt.figure(figsize=(15, 6))
plt.plot(test.index, test.values, label='Actual', color='black')
plt.plot(test.index, forecast, label='ARIMA', alpha=0.8)
plt.plot(test_lstm.index, y_pred, label='LSTM', alpha=0.8, linestyle='--')

plt.title('Model Comparison: MSFT Stock Price Forecast')
plt.xlabel('Date')
plt.ylabel('Close Price')
plt.legend()
plt.show()

pct_diff_arima_lstm = ((rmse_lstm - rmse) / rmse) * 100
print("LSTM RMSE is", round(pct_diff_arima_lstm,2), "% higher/lower than ARIMA.")